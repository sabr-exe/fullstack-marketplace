
===== .\.env =====
DJANGO_ENV=dev
DJANGO_DEBUG=True
DJANGO_SECRET_KEY=9f8a1c3d-REAL-LOCAL-SECRET-KEY

ALLOWED_HOSTS=localhost,127.0.0.1

DATABASE_URL=postgres://postgres:postgres@localhost:5432/emarket

REDIS_URL=redis://127.0.0.1:6379/1

SENTRY_DSN=

RELEASE=local

===== .\.env.example =====
# ==============================
# DJANGO CORE
# ==============================
DJANGO_ENV=dev
DJANGO_DEBUG=True
DJANGO_SECRET_KEY=change-this-secret-key

# ==============================
# HOSTS
# ==============================
ALLOWED_HOSTS=localhost,127.0.0.1

# ==============================
# DATABASE
# ==============================
DATABASE_URL=postgres://postgres:postgres@localhost:5432/emarket

# ==============================
# CACHE / REDIS
# ==============================
REDIS_URL=redis://127.0.0.1:6379/1

# ==============================
# SENTRY (optional)
# ==============================
SENTRY_DSN=

# ==============================
# RELEASE / VERSIONING
# ==============================
RELEASE=dev

===== .\copy_apps.py =====
from pathlib import Path


IGNORE_DIRS = {
    "__pycache__",
    "migrations",
    "tests",
}

IGNORE_FILES = {
    ".DS_Store",
}


def dump_apps_to_txt(project_root: Path, output_file: Path):
    apps_dir = project_root / "apps"

    if not apps_dir.exists():
        raise RuntimeError(f"'apps' directory not found in {project_root}")

    with open(output_file, "w", encoding="utf-8") as out:
        out.write("DUMP OF apps/\n")
        out.write("=" * 80 + "\n\n")

        for path in sorted(apps_dir.rglob("*")):
            # пропускаем директории
            if path.is_dir():
                continue

            # пропускаем лишние папки
            if any(part in IGNORE_DIRS for part in path.parts):
                continue

            # пропускаем лишние файлы
            if path.name in IGNORE_FILES:
                continue

            # пишем заголовок файла
            relative_path = path.relative_to(project_root)
            out.write("\n" + "#" * 80 + "\n")
            out.write(f"# FILE: {relative_path}\n")
            out.write("#" * 80 + "\n\n")

            try:
                content = path.read_text(encoding="utf-8")
            except Exception as e:
                out.write(f"<<ERROR READING FILE: {e}>>\n")
                continue

            out.write(content)
            out.write("\n")

    print(f"Apps dumped to: {output_file}")


if __name__ == "__main__":
    PROJECT_ROOT = Path(__file__).resolve().parent
    OUTPUT_FILE = PROJECT_ROOT / "apps_dump.txt"

    dump_apps_to_txt(PROJECT_ROOT, OUTPUT_FILE)

===== .\dump_project.py =====
import os

EXCLUDE = ["venv", "__pycache__", "migrations"]

with open("project_dump.txt", "w", encoding="utf-8") as out:
    for root, dirs, files in os.walk("."):
        if any(ex in root for ex in EXCLUDE):
            continue

        for file in files:
            path = os.path.join(root, file)
            out.write(f"\n===== {path} =====\n")
            try:
                with open(path, "r", encoding="utf-8") as f:
                    out.write(f.read())
            except:
                out.write("[binary file skipped]")

===== .\manage.py =====
import os
import sys


def main():
    os.environ.setdefault(
        "DJANGO_SETTINGS_MODULE",
        "e_market.settings.dev"
    )

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise

    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

===== .\project_dump.txt =====

===== .\requirements.txt =====
[binary file skipped]
===== .\apps\cart\admin.py =====
from django.contrib import admin
from .models import Cart, CartItem


class CartItemInline(admin.TabularInline):
    model = CartItem
    extra = 0


@admin.register(Cart)
class CartAdmin(admin.ModelAdmin):
    inlines = [CartItemInline]

===== .\apps\cart\apps.py =====
from django.apps import AppConfig


class CartConfig(AppConfig):
    name = 'apps.cart'

===== .\apps\cart\models.py =====
from django.conf import settings
from django.db import models
from apps.common.models import TimeStampedModel
from apps.products.models import Product
import uuid

class Cart(TimeStampedModel):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='cart'
    )

    def __str__(self):
        return f'Cart of {self.user}'



class CartItem(models.Model):
    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)  # ✅ новый публичный идентификатор unique=True

    cart = models.ForeignKey(
        Cart,
        on_delete=models.CASCADE,
        related_name='items'
    )
    product = models.ForeignKey(
        Product,
        on_delete=models.CASCADE
    )
    quantity = models.PositiveIntegerField(default=1)

    class Meta:
        #unique_together = ('cart', 'product')
        constraints = [
            models.UniqueConstraint(fields=['cart', 'product'], name='unique_cart_product')
        ]

    def __str__(self):
        return f'{self.product} x {self.quantity}'

===== .\apps\cart\serializers.py =====
from rest_framework import serializers
from .models import Cart, CartItem
from apps.products.models import Product


class CartItemSerializer(serializers.ModelSerializer):
    product_name = serializers.CharField(
        source='product.name', read_only=True
    )
    product_price = serializers.DecimalField(
        source='product.price',
        max_digits=10,
        decimal_places=2,
        read_only=True
    )

    class Meta:
        model = CartItem
        fields = (
            'id',
            'product',
            'product_name',
            'product_price',
            'quantity',
        )



class CartSerializer(serializers.ModelSerializer):
    items = CartItemSerializer(many=True, read_only=True)

    class Meta:
        model = Cart
        fields = ('id', 'items')



class AddToCartSerializer(serializers.Serializer):
    product_id = serializers.PrimaryKeyRelatedField(
        queryset=Product.objects.all(),
        source="product"
    )
    quantity = serializers.IntegerField(min_value=1, default=1)

    def validate(self, attrs):
        request = self.context["request"]
        user = request.user
        product = attrs["product"]
        quantity = attrs["quantity"]

        # 1. Проверяем, что товар активен
        if not product.is_active:
            raise serializers.ValidationError(
                {"product": "This product is not available for purchase"}
            )

        # 2. Проверяем, что quantity не превышает stock
        if quantity > product.stock:
            raise serializers.ValidationError(
                {"quantity": f"Only {product.stock} items available in stock"}
            )

        # 3. Проверяем существующее количество в корзине
        existing_qty = (
            CartItem.objects
            .filter(cart__user=user, product=product)
            .values_list("quantity", flat=True)
            .first() or 0
        )

        if existing_qty + quantity > product.stock:
            raise serializers.ValidationError(
                {"quantity": f"Total quantity exceeds stock ({product.stock})"}
            )

        return attrs




class UpdateCartItemSerializer(serializers.Serializer):
    item_id = serializers.IntegerField()
    quantity = serializers.IntegerField(min_value=1)



class RemoveCartItemSerializer(serializers.Serializer):
    item_id = serializers.IntegerField()



# class AddToCartSerializer(serializers.Serializer):
#     product_id = serializers.PrimaryKeyRelatedField(
#         queryset=Product.objects.all(),
#         source="product"
#     )
    
#     quantity = serializers.IntegerField(min_value=1, default=1)

#     def validate(self, attrs):
#         product = attrs["product"]
#         quantity = attrs["quantity"]

#         if quantity > product.stock:
#             raise serializers.ValidationError(
#                 {
#                     "quantity": f"Only {product.stock} items available in stock"
#                 }
#             )
#         existing_qty = (
#             CartItem.objects
#             .filter(cart__user=self.context["request"].user, product=product)
#             .values_list("quantity", flat=True)
#             .first() or 0
#         )

#         if existing_qty + quantity > product.stock:
#             raise serializers.ValidationError(
#                 {"quantity": f"Total quantity exceeds stock ({product.stock})"}
#             )

#         return attrs

===== .\apps\cart\tests.py =====
from django.test import TestCase

# Create your tests here.

===== .\apps\cart\urls.py =====
from django.urls import path
from .views import (
    CartView,
    AddToCartView,
    UpdateCartItemView,
    RemoveFromCartView,
)

urlpatterns = [
    path('cart/', CartView.as_view()),
    path('cart/add/', AddToCartView.as_view()),
    path('cart/update/', UpdateCartItemView.as_view()),
    path('cart/remove/', RemoveFromCartView.as_view()),
]

===== .\apps\cart\views.py =====
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status
from .models import Cart, CartItem
from .serializers import CartSerializer, AddToCartSerializer, UpdateCartItemSerializer, RemoveCartItemSerializer
from apps.products.models import Product
from django.shortcuts import get_object_or_404
from django.db import transaction, IntegrityError


class CartView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        try:
            cart = Cart.objects.prefetch_related(
                "items__product"  # Двойное подчеркивание протаскивает join дальше
            ).get(user=request.user)
        except Cart.DoesNotExist:
            try:
                with transaction.atomic():
                    cart = Cart.objects.create(user=request.user)
            except IntegrityError:
                # корзину создал параллельный запрос
                cart = Cart.objects.prefetch_related(
                    "items__product"
                ).get(user=request.user)

        serializer = CartSerializer(cart)
        return Response(serializer.data)



class AddToCartView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = AddToCartSerializer(data=request.data, context={"request": request})
        serializer.is_valid(raise_exception=True)

        product: Product = serializer.validated_data["product"]
        quantity: int = serializer.validated_data["quantity"]

        cart, _ = Cart.objects.get_or_create(user=request.user)

        with transaction.atomic():
            item, created = CartItem.objects.select_for_update().get_or_create(
                cart=cart,
                product=product,
                defaults={"quantity": 0},
            )
            item.quantity += quantity
            item.save(update_fields=["quantity"])

        return Response({'message': 'Added to cart'}, status=status.HTTP_201_CREATED)




class UpdateCartItemView(APIView):
    permission_classes = [IsAuthenticated]
    serializer_class = UpdateCartItemSerializer

    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)

        item_id = serializer.validated_data["item_id"]
        quantity = serializer.validated_data["quantity"]

        item = get_object_or_404(
             CartItem, id=item_id, cart__user=request.user )

        if quantity <= 0:
            item.delete()
            return Response({'message': 'Item removed'})

        item.quantity = quantity
        item.save()
        return Response({'message': 'Quantity updated'})




class RemoveFromCartView(APIView):
    permission_classes = [IsAuthenticated]
    serializer_class = RemoveCartItemSerializer

    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)

        item_id = serializer.validated_data["item_id"]

        item = get_object_or_404(
            CartItem,
            id=item_id,
            cart__user=request.user
        )

        item.delete()

        return Response({'message': 'Item removed'})



===== .\apps\cart\__init__.py =====

===== .\apps\common\admin.py =====
from django.contrib import admin

# Register your models here.

===== .\apps\common\apps.py =====
from django.apps import AppConfig


class CommonConfig(AppConfig):
    name = 'apps.common'

===== .\apps\common\middleware.py =====
import uuid
import hashlib
from sentry_sdk import set_user, set_tag

class SentryUserMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Генерация уникального request_id
        request_id = str(uuid.uuid4())
        request.request_id = request_id
        set_tag("request_id", request_id)

        # Установка пользователя в Sentry
        if hasattr(request, "user") and request.user.is_authenticated:
            email = request.user.email # or ""
            email_hash = hashlib.sha256(email.encode()).hexdigest()
            set_user({
                "id": request.user.id,
                "email": email_hash,
            })
        else:
            set_user(None)

        response = self.get_response(request)

        # Проброс request_id в заголовок
        response["X-Request-ID"] = request_id

        return response

===== .\apps\common\models.py =====
from django.db import models


class TimeStampedModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True

===== .\apps\common\permissions.py =====
from rest_framework.permissions import BasePermission, SAFE_METHODS



class IsAdminOrReadOnly(BasePermission):
    """
    Read — для всех
    Write — только для staff/admin
    """

    def has_permission(self, request, view):
        if request.method in SAFE_METHODS:
            return True

        return (
            request.user.is_authenticated
            and request.user.is_staff
        )

===== .\apps\common\tests.py =====
from django.test import TestCase

# Create your tests here.

===== .\apps\common\views.py =====
from django.shortcuts import render

# Create your views here.

===== .\apps\common\__init__.py =====

===== .\apps\core\admin.py =====
from django.contrib import admin

# Register your models here.

===== .\apps\core\apps.py =====
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.core"

    def ready(self):
        from . import checks

===== .\apps\core\checks.py =====
from django.core.checks import register, Error
from django.conf import settings
import os


@register()
def check_production_settings(app_configs, **kwargs):
    errors = []

    # DEBUG не должен быть включён в проде
    if not settings.DEBUG:
        pass
    else:
        errors.append(
            Error(
                "DEBUG is enabled in production",
                hint="Set DEBUG=False in production settings",
                id="core.E001",
            )
        )

    # SECRET_KEY должен приходить из env
    if not os.environ.get("DJANGO_SECRET_KEY"):
        errors.append(
            Error(
                "DJANGO_SECRET_KEY is not set",
                hint="Export DJANGO_SECRET_KEY in environment variables",
                id="core.E002",
            )
        )

    # ALLOWED_HOSTS не пуст
    if not settings.ALLOWED_HOSTS:
        errors.append(
            Error(
                "ALLOWED_HOSTS is empty",
                hint="Set ALLOWED_HOSTS in production",
                id="core.E003",
            )
        )

    return errors

===== .\apps\core\models.py =====
from django.db import models

# Create your models here.

===== .\apps\core\tests.py =====
from django.test import TestCase

# Create your tests here.

===== .\apps\core\urls.py =====
from django.urls import path
from .views import healthcheck, readiness, version



urlpatterns = [
    path("health/", healthcheck, name="healthcheck"),
    path("ready/", readiness, name="readiness"),
    path("version/", version, name="version"),

]

===== .\apps\core\views.py =====
from django.http import JsonResponse
from django.db import connection
from django.core.cache import cache
import os
from django.conf import settings

from django.http import HttpResponseForbidden


def internal_only(view_func):
    def wrapper(request, *args, **kwargs):
        x_forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
        if x_forwarded_for:
            ip = x_forwarded_for.split(",")[0].strip()
        else:
            ip = request.META.get("REMOTE_ADDR")

        if ip not in settings.INTERNAL_IPS:
            return HttpResponseForbidden()
        return view_func(request, *args, **kwargs)
    return wrapper


def healthcheck(request):
    """
    Liveness probe — просто проверяем, что Django жив
    """
    return JsonResponse({"status": "ok"})


@internal_only
def readiness(request):
    """
    Readiness probe — проверяем зависимости:
    - БД
    - Cache (если есть)
    """

    # Проверка базы
    try:
        connection.ensure_connection()
        db_status = "ok"
    except Exception:
        db_status = "error"

    # Проверка cache (redis / memcached)
    try:
        cache.set("healthcheck", "ok", timeout=1)
        cache_status = "ok"
    except Exception:
        cache_status = "error"

    status = "ok" if db_status == "ok" and cache_status == "ok" else "error"

    return JsonResponse(
        {
            "status": status,
            "database": db_status,
            "cache": cache_status,
        },
        status=200 if status == "ok" else 500,
    )




def version(request):
    return JsonResponse(
        {
            "service": "e_market",  #e_market.
            "environment": os.environ.get("DJANGO_ENV", "dev"),
            "version": os.environ.get("APP_VERSION", "unknown"),
            "debug": settings.DEBUG,
        }
    )

===== .\apps\core\__init__.py =====

===== .\apps\orders\admin.py =====
from django.contrib import admin, messages
from .models import Order, OrderItem, OrderStatusHistory
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _
from django.db import transaction

class OrderItemInline(admin.TabularInline):
    model = OrderItem
    extra = 0
    readonly_fields = ("product", "quantity", "price")


class OrderStatusHistoryInline(admin.TabularInline):
    model = OrderStatusHistory
    extra = 0
    readonly_fields = (
        "from_status",
        "to_status",
        "changed_by",
        "comment",
        "created_at",
    )
    can_delete = False

def _bulk_change_status(modeladmin, request, queryset, new_status):
    from .services import OrderService
    success = 0
    errors = []

    for order in queryset:
        try:
            with transaction.atomic():
                OrderService.change_status(
                    order_id=order.id,
                    new_status=new_status,
                    changed_by=request.user,
                    comment="Bulk change from admin"
                )
            success += 1
        except Exception as e:
            errors.append(f"#{order.id}: {e}")

    modeladmin.message_user(
        request,
        _("Changed %(count)s orders to %(status)s. %(errs)s") % {
            "count": success,
            "status": new_status,
            "errs": "" if not errors else "Errors: " + "; ".join(errors)
        }
    )

@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "user",
        "status",
        "delivery_method",
        "phone_number",
        "total_price",
        "created_at",
    )

    list_filter = (
        "status",
        "delivery_method",
        "created_at",
    )

    search_fields = (
        "id",
        "user__email",
        "phone_number",
    )

    readonly_fields = (
        "id",
        "user",
        "total_price",
        "created_at",
    )

    inlines = [
        OrderItemInline,
        OrderStatusHistoryInline,
    ]

    actions = (
        "make_confirmed",
        "make_shipped",
        "make_cancelled",
    )

    fieldsets = (
        ("Main", {
            "fields": (
                "id",
                "user",
                "status",
                "total_price",
                "created_at",
            )
        }),
        ("Contact", {
            "fields": (
                "phone_number",
            )
        }),
        ("Delivery", {
            "fields": (
                "delivery_method",
                "delivery_address",
                "delivery_time",
                "store_address",
            )
        }),
    )

    def save_model(self, request, obj, form, change):
        """
        Если статус меняют через админку —
        используем сервис, а не прямое сохранение
        """
        if change:
            old = Order.objects.get(pk=obj.pk)

            if old.status != obj.status:
                from .services import OrderService
                try:
                    OrderService.change_status(
                        order_id=old.id,
                        new_status=obj.status,
                        changed_by=request.user,
                        comment="Changed from admin panel",
                    )
                    # синхронизируем obj.status с тем, что в базе (чтобы super().save_model не перезаписал)
                    obj.status = Order.objects.get(pk=old.id).status
                except ValidationError as e:
                    self.message_user(request, str(e), level=messages.ERROR)
            super().save_model(request, obj, form, change)


 

    def make_confirmed(self, request, queryset):
        return _bulk_change_status(self, request, queryset, Order.Status.CONFIRMED)
    make_confirmed.short_description = _("Mark selected orders as confirmed")

    def make_shipped(self, request, queryset):
        return _bulk_change_status(self, request, queryset, Order.Status.SHIPPED)
    make_shipped.short_description = _("Mark selected orders as shipped")

    def make_cancelled(self, request, queryset):
        return _bulk_change_status(self, request, queryset, Order.Status.CANCELLED)
    make_cancelled.short_description = _("Mark selected orders as cancelled")

    def make_delivered(self, request, queryset):
        return _bulk_change_status(self, request, queryset, Order.Status.DELIVERED)
    make_delivered.short_description = _("Mark selected orders as delivered")

    def make_completed(self, request, queryset):
        return _bulk_change_status(self, request, queryset, Order.Status.COMPLETED)
    make_completed.short_description = _("Mark selected orders as completed")


    # Внутри OrderAdmin:
    actions = (
    "make_confirmed",
    "make_shipped",
    "make_delivered",
    "make_completed",
    "make_cancelled",
    )


===== .\apps\orders\apps.py =====
from django.apps import AppConfig


class OrdersConfig(AppConfig):
    name = 'apps.orders'
    
    def ready(self):
        import apps.orders

===== .\apps\orders\models.py =====
from django.conf import settings
from django.db import models
from apps.common.models import TimeStampedModel
from apps.products.models import Product


class Store(models.Model):
    name = models.CharField(max_length=100)
    address = models.CharField(max_length=255)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.name} — {self.address}"
    

class Order(TimeStampedModel):
    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        CONFIRMED = "confirmed", "Confirmed"
        SHIPPED = "shipped", "Shipped"
        DELIVERED = "delivered", "Delivered"  
        COMPLETED = "completed", "Completed"
        CANCELLED = "cancelled", "Cancelled"


    is_finalized = models.BooleanField(default=False)

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="orders"
    )

    customer_email = models.EmailField()
    shipping_address = models.TextField()

    status = models.CharField(
        max_length=20,
        default=Status.PENDING,
        db_index=True,
    )

    total_price = models.DecimalField(
        max_digits=10,
        decimal_places=2
    )

    currency = models.CharField(
        max_length=10,
        default="USD"
    )
    idempotency_key = models.CharField(
    max_length=64,
    default="",  # или сгенерировать uuid при создании
    blank=True,
)
    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["user", "idempotency_key"],
                name="unique_user_idempotency_key",
            )
        ]

    class DeliveryMethod(models.TextChoices):
        DELIVERY = "delivery", "Delivery"
        PICKUP = "pickup", "Pickup"

    delivery_method = models.CharField(
        max_length=20,
        choices=DeliveryMethod.choices,
    )

    phone_number = models.CharField(max_length=20)

    # Для доставки
    delivery_address = models.CharField(max_length=255, blank=True)
    delivery_time = models.DateTimeField(null=True, blank=True)

    # Для самовывоза
    store_address = models.CharField(max_length=255, blank=True)

    store = models.ForeignKey(
        Store,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
    )

    
    def __str__(self):
        return f"Order #{self.id}"




class OrderItem(models.Model):
    order = models.ForeignKey(
        Order,
        on_delete=models.CASCADE,
        related_name="items"
    )

    product = models.ForeignKey(
        Product,
        on_delete=models.PROTECT
    )

    product_name = models.CharField(max_length=255)

    price = models.DecimalField(
        max_digits=10,
        decimal_places=2
    )

    quantity = models.PositiveIntegerField()

    def __str__(self):
        return f"{self.product_name} x {self.quantity}"



class OrderStatusHistory(models.Model):
    order = models.ForeignKey(
        Order,
        related_name="status_history",
        on_delete=models.CASCADE,
    )

    from_status = models.CharField(max_length=20)
    to_status = models.CharField(max_length=20)

    changed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
    )

    comment = models.CharField(max_length=255, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.order.id}: {self.from_status} → {self.to_status}"

===== .\apps\orders\notifications.py =====

===== .\apps\orders\serializers.py =====
from rest_framework import serializers
from .models import Order, OrderItem
from django.utils import timezone
from .models import Order, OrderStatusHistory



class CreateOrderSerializer(serializers.Serializer):
    phone_number = serializers.CharField(max_length=20)
    delivery_method = serializers.ChoiceField(
        choices=Order.DeliveryMethod.choices
    )

    # delivery
    delivery_address = serializers.CharField(
        required=False,
        allow_blank=True
    )
    delivery_time = serializers.DateTimeField(
        required=False, allow_null=True
    )

    # pickup
    store_address = serializers.CharField(
        required=False,
        allow_blank=True
    )
    customer_email = serializers.EmailField(required=False, allow_blank=True)
    shipping_address = serializers.CharField(required=False, allow_blank=True)
 
    def validate_phone_number(self, value):
        digits = [c for c in value if c.isdigit()]
        if len(digits) < 10:
            raise serializers.ValidationError("Invalid phone number")
        return value

    def validate(self, attrs):
        method = attrs.get("delivery_method")

        # fallback email
        if not attrs.get("customer_email"):
            user = self.context["request"].user
            attrs["customer_email"] = getattr(user, "email", None)

        if not attrs["customer_email"]:
            raise serializers.ValidationError({
                "customer_email": "Email is required"
            })

        # DELIVERY
        if method == Order.DeliveryMethod.DELIVERY:
            if not attrs.get("delivery_address"):
                raise serializers.ValidationError({
                    "delivery_address": "Delivery address is required"
                })

            delivery_time = attrs.get("delivery_time")
            if not delivery_time:
                raise serializers.ValidationError({
                    "delivery_time": "Delivery time is required"
                })

            if delivery_time < timezone.now():
                raise serializers.ValidationError({
                    "delivery_time": "Delivery time must be in the future"
                })

        # PICKUP
        elif method == Order.DeliveryMethod.PICKUP:
            if not attrs.get("store_address"):
                raise serializers.ValidationError({
                    "store_address": "Store address is required for pickup"
                })

        return attrs




class OrderItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = OrderItem
        fields = (
            'product',
            'product_name',
            'price',
            'quantity',
        )
        read_only_fields = ("product_name", "price")

class OrderStatusHistorySerializer(serializers.ModelSerializer):
    changed_by = serializers.StringRelatedField()

    class Meta:
        model = OrderStatusHistory
        fields = (
            "from_status",
            "to_status",
            "changed_by",
            "comment",
            "created_at",
        )




class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True, read_only=True)
    status_history = OrderStatusHistorySerializer(
        many=True,
        read_only=True,
        
        #source="status_history"
    )

    class Meta:
        model = Order
        fields = (
             "id",
            "status",
            "delivery_method",
            "phone_number",
            "delivery_address",
            "delivery_time",
            "store_address",
            "total_price",
            "created_at",
            "items",
            "status_history",

        )


class ChangeOrderStatusSerializer(serializers.Serializer):
    status = serializers.ChoiceField(choices=Order.Status.choices)
    comment = serializers.CharField(required=False, allow_blank=True)


    

===== .\apps\orders\services.py =====
from django.db import transaction, IntegrityError
from django.core.exceptions import ValidationError
from .models import Order, OrderItem, OrderStatusHistory
from apps.cart.models import CartItem
from apps.products.models import Product
import logging
from decimal import Decimal
from uuid import uuid4

logger = logging.getLogger(__name__)


class OrderService:
    @staticmethod
    def create_order(
        user,
        idempotency_key,
        phone_number,
        delivery_method,
        delivery_address=None,
        delivery_time=None,
        store_address=None,
        customer_email=None,
        shipping_address=None,
    ):
        # Генерация idempotency_key, если фронт не прислал 
        if not idempotency_key: 
            idempotency_key = str(uuid4())
        """
        Idempotent, deadlock-safe order creation with full observability.
        """
        # Observability: start
        try:
            cart_size = CartItem.objects.filter(cart__user=user).count()
        except Exception:
            cart_size = None

        logger.info(
            "checkout_started",
            extra={
                "user_id": getattr(user, "id", None),
                "idempotency_key": idempotency_key,
                "cart_size": cart_size,
            },
        )

        try:
            with transaction.atomic():
                # 1) Idempotency fast-path (block existing order row if exists)
                existing = (
                    Order.objects
                    .select_for_update()
                    .filter(user=user, idempotency_key=idempotency_key)
                    .first()
                )
                if existing:
                    logger.info(
                        "checkout_idempotent_hit",
                        extra={"order_id": existing.id, "user_id": getattr(user, "id", None)},
                    )
                    return existing, False

                # 2) Получаем позиции корзины в детерминированном порядке
                cart_items_qs = (
                    CartItem.objects
                    .select_related("product", "cart")
                    .filter(cart__user=user)
                    .order_by("product_id")   # <- важно для детерминированной блокировки
                )

                if not cart_items_qs.exists():
                    logger.warning(
                        "checkout_empty_cart",
                        extra={"user_id": getattr(user, "id", None)},
                    )
                    raise ValidationError("Cart is empty")

                # 3) Блокируем Product-строки в детерминированном порядке (по pk)
                product_ids = list(cart_items_qs.values_list("product_id", flat=True).distinct())
                products_qs = Product.objects.filter(pk__in=product_ids).order_by("pk").select_for_update()
                products = {p.pk: p for p in products_qs}

                # 4) Проверяем stock и резервируем (меняем объект и сохраняем)
                total_price = Decimal("0")
                order_items = []

                for ci in cart_items_qs:
                    p = products.get(ci.product_id)
                    if p is None:
                        logger.error(
                            "checkout_product_missing",
                            extra={"product_id": ci.product_id, "user_id": getattr(user, "id", None)},
                        )
                        raise ValidationError(f"Product {ci.product_id} not found")

                    if p.stock < ci.quantity:
                        logger.warning(
                            "checkout_out_of_stock",
                            extra={
                                "product_id": p.pk,
                                "available": p.stock,
                                "requested": ci.quantity,
                                "user_id": getattr(user, "id", None),
                            },
                        )
                        raise ValidationError(f"Not enough stock for product {p.pk}")

                    # резервируем
                    p.stock -= ci.quantity
                    p.save(update_fields=["stock"])

                    # подготовка OrderItem
                    order_items.append(
                        OrderItem(
                            order=None,  # временно, присвоим order после создания
                            product=p,
                            product_name=p.name if hasattr(p, "name") else "",
                            quantity=ci.quantity,
                            price=p.price,
                        )
                    )

                    # суммирование
                    total_price += (p.price * ci.quantity)

                # 5) Создаём Order (после успешного резервирования)
                try:
                    order = Order.objects.create(
                        user=user,
                        idempotency_key=idempotency_key,
                        phone_number=phone_number,
                        delivery_method=delivery_method,
                        delivery_address=delivery_address or "",
                        delivery_time=delivery_time,
                        store_address=store_address or "",
                        customer_email=customer_email,
                        shipping_address=shipping_address or "",
                        status=Order.Status.PENDING,
                        total_price=total_price,   # ✅ сразу правильная цена
                        is_finalized=True,
                    )
                except IntegrityError:
                    # Редкая гонка — кто-то параллельно создал заказ с тем же idempotency_key
                    existing = Order.objects.filter(user=user, idempotency_key=idempotency_key).first()
                    if existing:
                        logger.info(
                            "checkout_idempotent_race_resolved",
                            extra={
                                "order_id": existing.id, 
                                "user_id": getattr(user, "id", None),
                                "idempotency_key": idempotency_key,  
                                },
                        )
                        return existing, False
                    raise

                # 6) Сохраняем OrderItems, присвоив order
                for oi in order_items:
                    oi.order = order
                OrderItem.objects.bulk_create(order_items)

                # 7) Финализируем заказ
                # order.total_price = total_price
                # order.is_finalized = True
                # order.save(update_fields=["total_price", "is_finalized"])

                # 8) Очищаем корзину
                cart_items_qs.delete()

                logger.info(
                    "checkout_created",
                    extra={
                        "order_id": order.id,
                        "user_id": getattr(user, "id", None),
                        "total_price": str(order.total_price),
                        "items_count": len(order_items),
                    },
                )

                return order, True

        except Exception as exc:
            logger.exception(
                "checkout_failed",
                exc_info=exc,
                extra={"user_id": getattr(user, "id", None), "idempotency_key": idempotency_key},
            )
            raise


    @staticmethod
    def change_status(order_id, new_status, changed_by=None, comment=""):
        """
        Change order status atomically, write history and send notifications.
        """
        try:
            with transaction.atomic():
                # lock order
                order = Order.objects.select_for_update().get(pk=order_id)
                old_status = order.status

                if old_status == new_status:
                    return order, False

                # Optional business-rule check
                try:
                    from .utils import OrderStatusFlow
                    if not OrderStatusFlow.can_change(old_status, new_status):
                        raise ValidationError(f"Cannot change status from {old_status} to {new_status}")
                except ImportError:
                    pass

                order.status = new_status
                order.save(update_fields=["status"])

                OrderStatusHistory.objects.create(
                    order=order,
                    from_status=old_status,
                    to_status=new_status,
                    changed_by=changed_by,
                    comment=comment,
                )

            # outside transaction: send notification (or send asynchronously inside job)
            if str(new_status).lower() == "shipped":
                try:
                    from .notifications import send_order_shipped_email
                    send_order_shipped_email(order)
                except Exception:
                    logger.exception("failed_to_send_order_shipped_email", extra={"order_id": order.id})

            logger.info(
                "order_status_changed",
                extra={
                    "order_id": order.id,
                    "from_status": old_status,
                    "to_status": new_status,
                    "changed_by": getattr(changed_by, "id", None),
                },
            )

            return order, True

        except Exception as exc:
            logger.exception(
                "order_status_change_failed",
                exc_info=exc,
                extra={
                    "order_id": order_id,
                    "from_status": locals().get("old_status", None),
                    "to_status": new_status,
                    "changed_by": getattr(changed_by, "id", None),
                },
            )
            raise


class OrderStatusFlow:

    ALLOWED_TRANSITIONS = {
        Order.Status.PENDING: [Order.Status.CONFIRMED, Order.Status.CANCELLED],
        Order.Status.CONFIRMED: [Order.Status.SHIPPED, Order.Status.CANCELLED],
        Order.Status.SHIPPED: [Order.Status.DELIVERED],       
        Order.Status.DELIVERED: [Order.Status.COMPLETED],     
        Order.Status.COMPLETED: [],                            
        Order.Status.CANCELLED: [],
    }

    @classmethod
    def can_change(cls, from_status, to_status):
        return to_status in cls.ALLOWED_TRANSITIONS.get(from_status, [])

===== .\apps\orders\signals.py =====
# from django.db.models.signals import post_save
# from django.dispatch import receiver
# from django.core.mail import send_mail
# from .models import Order


# @receiver(post_save, sender=Order)
# def order_status_changed(sender, instance, created, **kwargs):
#     if instance.status == 'shipped':
#         send_mail(
#             subject='Ваш заказ отправлен',
#             message=f'Ваш заказ №{instance.id} отправлен.',
#             from_email='shop@example.com',
#             recipient_list=[instance.user.email],
#             fail_silently=True,
#         )

===== .\apps\orders\tests.py =====

===== .\apps\orders\urls.py =====
from django.urls import path
from .views import (
    CreateOrderView,
    OrderListView,
    OrderDetailView,
    ChangeOrderStatusView,
)

urlpatterns = [
    path('orders/', OrderListView.as_view()),
    path('orders/create/', CreateOrderView.as_view()),
    path('orders/<int:pk>/', OrderDetailView.as_view()),
    path("orders/<int:order_id>/change-status/", ChangeOrderStatusView.as_view()),

]

===== .\apps\orders\utils.py =====
# """
# Business rules for order status transitions.

# Provides:
# - OrderStatus enum-like constants (strings) to use across the codebase
# - OrderStatusFlow: deterministic rules which states can transit to which
# - helpers: can_change(), next_allowed(), is_terminal()

# Why:
# Centralizes business rules (Single Source of Truth). Tests and admin code
# should rely on these functions instead of ad-hoc checks spread around.
# """

# from typing import Set, Dict, Iterable, Optional


# class OrderStatus:
#     """
#     Canonical status names. Use these constants everywhere (models/serializers/services).
#     They are strings to match common Django storage patterns (CharField choices).
#     """
#     CREATED = "created"
#     PENDING = "pending"   # e.g. created but waiting for payment verification
#     PAID = "paid"
#     PROCESSING = "processing"  # warehouse picking/packing
#     SHIPPED = "shipped"
#     DELIVERED = "delivered"
#     CANCELED = "canceled"
#     FAILED = "failed"  # payment failed, etc.
#     RETURNED = "returned"

#     @classmethod
#     def all(cls) -> Iterable[str]:
#         return [
#             cls.CREATED, cls.PENDING, cls.PAID, cls.PROCESSING,
#             cls.SHIPPED, cls.DELIVERED, cls.CANCELED, cls.FAILED, cls.RETURNED
#         ]


# class OrderStatusFlow:
#     """
#     Defines allowed transitions between order statuses.

#     Rules are intentionally conservative. If you need to change business logic
#     (e.g. allow `paid -> returned`), update FLOW and add unit tests.
#     """

#     # FLOW[from_status] = set(of allowed to_status)
#     FLOW: Dict[str, Set[str]] = {
#         OrderStatus.CREATED: {OrderStatus.PENDING, OrderStatus.CANCELED},
#         OrderStatus.PENDING: {OrderStatus.PAID, OrderStatus.CANCELED, OrderStatus.FAILED},
#         OrderStatus.PAID: {OrderStatus.PROCESSING, OrderStatus.CANCELED},
#         OrderStatus.PROCESSING: {OrderStatus.SHIPPED, OrderStatus.CANCELED},
#         OrderStatus.SHIPPED: {OrderStatus.DELIVERED, OrderStatus.RETURNED},
#         OrderStatus.DELIVERED: set(),
#         OrderStatus.CANCELED: set(),
#         OrderStatus.FAILED: {OrderStatus.CANCELED},
#         OrderStatus.RETURNED: set(),
#     }

#     TERMINAL_STATES = {
#         OrderStatus.DELIVERED,
#         OrderStatus.CANCELED,
#         OrderStatus.RETURNED,
#     }

#     @classmethod
#     def can_change(cls, old_status: Optional[str], new_status: str) -> bool:
#         """
#         Returns True if transition old_status -> new_status is allowed.
#         If old_status is None, treat it as CREATED allowed.
#         """
#         if old_status is None:
#             old_status = OrderStatus.CREATED
#         old_status = str(old_status)
#         new_status = str(new_status)
#         allowed = cls.FLOW.get(old_status, set())
#         return new_status in allowed

#     @classmethod
#     def next_allowed(cls, old_status: Optional[str]) -> Set[str]:
#         """Return set of allowed next statuses from old_status."""
#         if old_status is None:
#             old_status = OrderStatus.CREATED
#         return set(cls.FLOW.get(str(old_status), set()))

#     @classmethod
#     def is_terminal(cls, status: Optional[str]) -> bool:
#         return str(status) in cls.TERMINAL_STATES


# # Optional: convenience function used in serializers / validators
# def validate_status_transition(old_status: Optional[str], new_status: str) -> None:
#     """
#     Raises ValueError if transition is not allowed (useful in serializers/services).
#     """
#     if not OrderStatusFlow.can_change(old_status, new_status):
#         raise ValueError(f"Cannot change order status from {old_status} to {new_status}")

===== .\apps\orders\views.py =====
from .serializers import OrderSerializer
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated, IsAdminUser
from rest_framework.response import Response
from rest_framework import status
from django.shortcuts import get_object_or_404
from .models import Order
from .services import OrderService
from django.core.exceptions import ValidationError
from .serializers import CreateOrderSerializer, ChangeOrderStatusSerializer, OrderStatusHistorySerializer


class CreateOrderView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        idempotency_key = request.headers.get("Idempotency-Key")

        if not idempotency_key:
            return Response(
                {"detail": "Idempotency-Key header is required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        serializer = CreateOrderSerializer(data=request.data, context={"request": request})
        # проверка на ошибку
        if not serializer.is_valid(): 
            print("ERRORS:", serializer.errors) 
            return Response(serializer.errors, status=400)
        #
        serializer.is_valid(raise_exception=True)

        data = serializer.validated_data

        try:
            order, created = OrderService.create_order(
                user=request.user,
                idempotency_key=idempotency_key,
                phone_number=data["phone_number"],
                delivery_method=data["delivery_method"],
                delivery_address=data.get("delivery_address", ""),
                delivery_time=data.get("delivery_time"),
                store_address=data.get("store_address", ""),
                customer_email=data.get("customer_email"),
                shipping_address=data.get("shipping_address"),
            )
        except ValidationError as e:
            return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        return Response(
            {
                "order_id": order.id,
                "status": order.status,
                "total_price": order.total_price,
                "delivery_method": order.delivery_method,
            },
            status=status.HTTP_201_CREATED if created else status.HTTP_200_OK,
        )



class OrderListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        orders = Order.objects.filter(user=request.user)
        serializer = OrderSerializer(orders, many=True)
        return Response(serializer.data)



class OrderDetailView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, pk):
        order = get_object_or_404(
            Order.objects
            .filter(user=request.user)
            .prefetch_related(
                "items__product",
                "status_history",
            ),
            id=pk,
        )

        serializer = OrderSerializer(order)
        # views.py
        #serializer = OrderSerializer(data=request.data)
        #print(request.data)
        #print(serializer.errors)

        return Response(serializer.data)


class ChangeOrderStatusView(APIView):
    permission_classes = [IsAdminUser]

    def post(self, request, order_id):
        try:
            order = Order.objects.get(id=order_id)
        except Order.DoesNotExist:
            return Response(
                {"detail": "Order not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        serializer = ChangeOrderStatusSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        try:
            # Вызов сервиса: используем order_id чтобы соответствовать сигнатуре OrderService.change_status(order_id, ...)
            OrderService.change_status(
                order_id=order.id,
                new_status=serializer.validated_data["status"],
                changed_by=request.user,
                comment=serializer.validated_data.get("comment", ""),
            )
        except ValidationError as e:
            return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        # Обновим объект из БД чтобы вернуть актуальный статус
        order.refresh_from_db()

        return Response(
            {
                "order_id": order.id,
                "status": order.status,
            }
        )

===== .\apps\orders\__init__.py =====

===== .\apps\products\admin.py =====
from django.contrib import admin
from .models import Category, Product, ProductImage, ProductAttributeValue, ProductAttribute

class ProductAttributeValueInline(admin.TabularInline):
    model = ProductAttributeValue
    extra = 1


@admin.register(ProductAttribute) 
class ProductAttributeAdmin(admin.ModelAdmin): 
    list_display = ("name", "slug", "value_type") 
    search_fields = ("name", "slug") 
    list_filter = ("value_type",) 
    prepopulated_fields = {"slug": ("name",)}

class ProductImageInline(admin.TabularInline):
    model = ProductImage
    extra = 1


@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}
    list_display = ('name', 'parent', 'is_active')


@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}
    list_display = ('name', 'price', 'stock', 'is_active')
    list_filter = ('is_active',)
    search_fields = ('name',)
    inlines = [ProductAttributeValueInline, ProductImageInline]


===== .\apps\products\apps.py =====
from django.apps import AppConfig


class ProductsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.products"

    def ready(self):
        # ВАЖНО: импортируем сигналы здесь
        import apps.products.signals  

===== .\apps\products\filters.py =====
import django_filters
from django.db.models import Q
from .models import Product, Category


class ProductFilter(django_filters.FilterSet):
    min_price = django_filters.NumberFilter(
        field_name="price",
        lookup_expr="gte",
    )
    max_price = django_filters.NumberFilter(
        field_name="price",
        lookup_expr="lte",
    )

    category = django_filters.CharFilter(
        method="filter_category"
    )

    in_stock = django_filters.BooleanFilter(
        method="filter_in_stock"
    )

    class Meta:
        model = Product
        fields = [
            "category",
            "min_price",
            "max_price",
            "in_stock",
        ]

    def filter_category(self, queryset, name, value):
        """
        value = slug категории
        """
        try:
            category = Category.objects.get(slug=value)
        except Category.DoesNotExist:
            return queryset.none()

        # если есть MPTT
        if hasattr(category, "get_descendants"):
            categories = category.get_descendants(include_self=True)
            return queryset.filter(category__in=categories)

        # fallback: если нет MPTT — вручную (2 уровня)
        child_ids = Category.objects.filter(
            Q(id=category.id) |
            Q(parent=category) |
            Q(parent__parent=category)
        ).values_list("id", flat=True)

        return queryset.filter(category_id__in=child_ids)

    def filter_in_stock(self, queryset, name, value):
        if value:
            return queryset.filter(stock__gt=0)
        return queryset

===== .\apps\products\models.py =====
from .validators import validate_image_mime, validate_image_size
import uuid
from apps.common.models import TimeStampedModel
from django.core.exceptions import ValidationError
from django.db import models

class Category(TimeStampedModel):
    name = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='children'
    )
    is_active = models.BooleanField(default=True)

    class Meta:
        verbose_name_plural = 'Categories'

    def __str__(self):
        return self.name

    def clean(self):
        """
        Защита от циклов:
        A -> B -> C -> A
        """
        parent = self.parent
        while parent:
            if parent == self:
                raise ValidationError("Category cannot be parent of itself or create a cycle")
            parent = parent.parent




class Product(TimeStampedModel):
    category = models.ForeignKey(
        Category,
        on_delete=models.PROTECT,
        related_name="products",
    )

    name = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)

    description = models.TextField(blank=True)

    price = models.DecimalField(max_digits=10, decimal_places=2)

    old_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
    )

    # рейтинг 0.0 – 5.0
    rating = models.DecimalField(
        max_digits=2,
        decimal_places=1,
        default=0,
    )

    # остаток — только >= 0
    stock = models.PositiveIntegerField(default=0)

    is_active = models.BooleanField(default=True)

    class Meta:
        indexes = [
            models.Index(fields=["is_active"]),
            models.Index(fields=["price"]),
            models.Index(fields=["category", "is_active"]),
            models.Index(fields=["slug"]),
        ]
        constraints = [
            # защита от отрицательного остатка
            models.CheckConstraint(
                condition=models.Q(stock__gte=0),
                name="product_stock_non_negative",
            ),
            # рейтинг всегда в диапазоне 0–5
            models.CheckConstraint(
                condition=models.Q(rating__gte=0) & models.Q(rating__lte=5),
                name="product_rating_range",
            ),
        ]

    def __str__(self):
        return self.name


def product_image_path(instance, filename):
    ext = filename.split('.')[-1]
    filename = f"{uuid.uuid4()}.{ext}"
    return f"products/{instance.product_id}/{filename}" 
    
class ProductImage(models.Model):
    product = models.ForeignKey(
        Product,
        on_delete=models.CASCADE,
        related_name="images",
    )

    image = models.ImageField(
        upload_to=product_image_path,
        validators=[validate_image_size, validate_image_mime]
    )
    is_main = models.BooleanField(default=False)

    class Meta:
        # гарантируем: только одно главное изображение на продукт
        constraints = [
            models.UniqueConstraint(
                fields=["product"],
                condition=models.Q(is_main=True),
                name="unique_main_image_per_product",
            )
        ]
        indexes = [
            models.Index(fields=["product"]),
        ]
    def clean(self):
        # Если это главное изображение — проверяем, что оно единственное
        if self.is_main:
            qs = ProductImage.objects.filter(product=self.product, is_main=True)
            if self.pk:
                qs = qs.exclude(pk=self.pk)
            if qs.exists():
                raise ValidationError("Main image already exists for this product.")
            
    def __str__(self):
        return f"Image for {self.product.name}"


# products/models.py

class ProductAttribute(models.Model):
    TEXT = "text"
    NUMBER = "number"
    BOOLEAN = "bool"

    VALUE_TYPES = [
        (TEXT, "Text"),
        (NUMBER, "Number"),
        (BOOLEAN, "Boolean"),
    ]

    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    unit = models.CharField(max_length=20, blank=True)
    value_type = models.CharField(
        max_length=10,
        choices=VALUE_TYPES,
        default=TEXT
    )

    categories = models.ManyToManyField(
        Category,
        related_name="attributes"
    )
    class Meta:
        indexes = [
            models.Index(fields=["slug"]),
        ]
    def __str__(self):
        return self.name


class ProductAttributeValue(models.Model):
    product = models.ForeignKey(
        Product,
        related_name="attributes",
        on_delete=models.CASCADE
    )
    attribute = models.ForeignKey(
        ProductAttribute,
        on_delete=models.CASCADE
    )
    value_text = models.CharField(max_length=255, blank=True)
    value_number = models.DecimalField(
        max_digits=10, decimal_places=2,
        null=True, blank=True
    )
    value_bool = models.BooleanField(null=True, blank=True)

    class Meta:
        unique_together = ("product", "attribute")
        indexes = [
            models.Index(fields=["attribute", "value_text"]),
            models.Index(fields=["attribute", "value_number"]),
        ]
    def __str__(self):
        # возвращаем значение в зависимости от типа данных
        if self.value_number is not None:
            val = str(self.value_number)
        elif self.value_bool is not None:
            val = str(self.value_bool)
        else:
            val = self.value_text or ""
        return f"{self.product} | {self.attribute}: {val}"
===== .\apps\products\serializers.py =====
from rest_framework import serializers
from .models import Category, Product, ProductImage, ProductAttribute, ProductAttributeValue



class CategorySerializer(serializers.ModelSerializer):
    children = serializers.SerializerMethodField()
    

    class Meta:
        model = Category
        fields = (
            'id',
            'name',
            'slug',
            'parent',
            'children',
        )

    def get_children(self, obj):
        return CategorySerializer(
            obj.children.filter(is_active=True),
            many=True
        ).data



class ProductImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductImage
        fields = ('id', 'image', 'is_main')



class ProductListSerializer(serializers.ModelSerializer):
    main_image = serializers.SerializerMethodField()
    reviews_count = serializers.IntegerField(read_only=True)

    class Meta:
        model = Product
        fields = (
            "id",
            "name",
            "price",
            "main_image",
            "reviews_count",
        )

    def get_main_image(self, obj):
        # если prefetch_related использован — obj.images.all() уже закэширован
        images = list(getattr(obj, "images").all()) if hasattr(obj, "images") else []
        if images:
            request = self.context.get("request")
            url = images[0].image.url
            if request:
                return request.build_absolute_uri(url)
            return url
        return None


class ProductAttributeValueSerializer(serializers.ModelSerializer):
    attribute = serializers.CharField(source="attribute.name", read_only=True)
    slug = serializers.CharField(source="attribute.slug", read_only=True)
    value = serializers.SerializerMethodField()

    class Meta:
        model = ProductAttributeValue
        fields = ("attribute", "slug", "value")

    def get_value(self, obj):
        attr_type = obj.attribute.value_type

        if attr_type == ProductAttribute.TEXT:
            return obj.value_text

        if attr_type == ProductAttribute.NUMBER:
            return obj.value_number

        if attr_type == ProductAttribute.BOOLEAN:
            if obj.value_bool is True:
                return "yes"
            if obj.value_bool is False:
                return "no"
            return "unknown"

        return None


class ProductDetailSerializer(serializers.ModelSerializer):
    images = ProductImageSerializer(many=True, read_only=True)
    rating = serializers.DecimalField(max_digits=3, decimal_places=1, read_only=True)
    reviews_count = serializers.IntegerField(read_only=True)
    attributes = ProductAttributeValueSerializer(many=True, read_only=True)
    class Meta:
        model = Product
        fields = (
            'id',
            'name',
            'slug',
            'description',
            'price',
            'old_price',
            'stock',
            'images',
            'rating',
            'reviews_count',
            'attributes',
        )





===== .\apps\products\signals.py =====
import logging
from django.db.models.signals import post_delete, pre_save
from django.dispatch import receiver
from .models import ProductImage
from django.db import transaction

logger = logging.getLogger("products.signals")


def _delete_file(file_field):
    if not file_field:
        return

    try:
        storage = file_field.storage
        name = file_field.name

        if name and storage.exists(name):
            storage.delete(name)

    except Exception as exc:
        logger.error(
            "file_delete_failed",
            extra={
                "file": getattr(file_field, "name", None),
                "error": str(exc),
            },
            exc_info=True,
        )


@receiver(post_delete, sender=ProductImage)
def delete_image_file_on_delete(sender, instance, **kwargs):
    """
    Удаляет файл при удалении ProductImage.
    """
    image = instance.image 
    
    transaction.on_commit(lambda: _delete_file(image))

    logger.info(
        "product_image_deleted",
        extra={
            "product_id": instance.product_id,
            "image_id": instance.id,
        },
    )


@receiver(pre_save, sender=ProductImage)
def delete_old_image_on_update(sender, instance, **kwargs):
    """
    Удаляет старый файл при обновлении изображения.
    """
    if not instance.pk:
        return

    try:
        old = ProductImage.objects.get(pk=instance.pk)
    except ProductImage.DoesNotExist:
        return

    if old.image and old.image != instance.image:
        old_image = old.image 
        transaction.on_commit(lambda: _delete_file(old_image))
        
        logger.info(
            "product_image_replaced",
            extra={
                "product_id": instance.product_id,
                "image_id": instance.id,
            },
        )

===== .\apps\products\tests.py =====
from django.test import TestCase

# Create your tests here.

===== .\apps\products\urls.py =====
from rest_framework.routers import DefaultRouter
from .views import CategoryViewSet, ProductViewSet

router = DefaultRouter()
router.register('categories', CategoryViewSet)
router.register('products', ProductViewSet, basename='products')

urlpatterns = router.urls

===== .\apps\products\validators.py =====
from django.core.exceptions import ValidationError

def validate_image_size(image):
    max_size = 5 * 1024 * 1024  # 5MB
    if image.size > max_size:
        raise ValidationError("Image too large (max 5MB)")

def validate_image_mime(image):
    if image.content_type not in ["image/jpeg", "image/png", "image/webp"]:
        raise ValidationError("Only JPG, PNG, WEBP allowed")

===== .\apps\products\views.py =====
from django.db.models import Count, Prefetch
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator

from rest_framework.viewsets import ReadOnlyModelViewSet, ModelViewSet
from rest_framework.pagination import PageNumberPagination
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend
from .filters import ProductFilter

from .models import Category, Product, ProductImage
from .serializers import (
    CategorySerializer,
    ProductDetailSerializer,
    ProductListSerializer,
)


# PAGINATION
class StandardResultsPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = "page_size"
    max_page_size = 100



# PRODUCT VIEWSET
class ProductViewSet(ModelViewSet):
    """
    Product catalog API:
    - filtering (category, price, stock)
    - search (name, description)
    - ordering (price, rating, created_at)
    - pagination
    - caching (list + retrieve)
    """
    pagination_class = StandardResultsPagination

    # фильтры
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]

    filterset_class = ProductFilter      # ВАЖНО: используем свой фильтр
    search_fields = ["name", "description"]
    ordering_fields = ["price", "rating", "created_at"]
    ordering = ["-created_at"]


    # ---- QUERYSET ----
    def get_queryset(self):
        qs = (
            Product.objects
            .select_related("category")
            .prefetch_related(
                Prefetch(
                    "images",
                    queryset=ProductImage.objects.order_by("-is_main", "id")
                )
            )
            .annotate(reviews_count=Count("reviews", distinct=True))
        )

        user = self.request.user
        # staff видит всё
        if user.is_authenticated and user.is_staff:
            return qs
        
        # обычные пользователи — только активные товары
        return qs.filter(is_active=True)
    
    def get_serializer_class(self):
        if self.action == "list":
            return ProductListSerializer

        if self.action == "retrieve":
            return ProductDetailSerializer

        # create / update / delete — отдельный сериалайзер можно потом вынести
        return ProductDetailSerializer
    
    def list(self, request, *args, **kwargs):
        """
        Cache product list for 60 seconds
        """
        return super().list(request, *args, **kwargs)
    
    @method_decorator(cache_page(300))
    def retrieve(self, request, *args, **kwargs):
        """
        Cache product detail for 5 minutes
        """
        return super().retrieve(request, *args, **kwargs)


class CategoryViewSet(ReadOnlyModelViewSet):
    queryset = (
        Category.objects
        .filter(is_active=True, parent__isnull=True)
        .prefetch_related("children")
        .order_by("name")
    )

    serializer_class = CategorySerializer

    @method_decorator(cache_page(300))
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

===== .\apps\products\__init__.py =====

===== .\apps\products\management\__init__.py =====

===== .\apps\products\management\commands\clear_p.py =====
from faker import Faker
from django.core.management.base import BaseCommand
from django.utils.text import slugify
from django.contrib.auth import get_user_model

from apps.products.models import (
    Category,
    Product,
    ProductImage,
    ProductAttribute,
    ProductAttributeValue,
)
from apps.reviews.models import Review
from apps.orders.models import Order, OrderItem, Store
from apps.cart.models import Cart, CartItem

fake = Faker()
User = get_user_model()


class Command(BaseCommand):
    help = "Clear all product-related data safely and consistently"

    def handle(self, *args, **options):
        self.stdout.write(self.style.WARNING("Clearing database..."))
        self.clear_all()
        self.stdout.write(self.style.SUCCESS("Database cleared successfully."))

    # ============================================================
    # CLEAR ALL DATA (correct FK order)
    # ============================================================
    def clear_all(self):
        # 1. Reviews → OrderItem → Order
        Review.objects.all().delete()
        OrderItem.objects.all().delete()
        Order.objects.all().delete()

        # 2. CartItem → Cart
        CartItem.objects.all().delete()
        Cart.objects.all().delete()

        # 3. Product images (safe deletion via signals)
        ProductImage.objects.all().delete()

        # 4. Product attributes
        ProductAttributeValue.objects.all().delete()
        ProductAttribute.objects.all().delete()

        # 5. Products
        Product.objects.all().delete()

        # 6. Categories
        Category.objects.all().delete()

        # 7. Stores
        Store.objects.all().delete()

        # 8. Users (except superuser)
        User.objects.exclude(is_superuser=True).delete()

===== .\apps\products\management\commands\seed_p.py =====
import random
import requests
from faker import Faker
from django.core.files.base import ContentFile
from django.core.management.base import BaseCommand
from django.utils.text import slugify
from django.contrib.auth import get_user_model
from django.db import transaction

from apps.products.models import (
    Category,
    Product,
    ProductImage,
    ProductAttribute,
    ProductAttributeValue,
)
from apps.reviews.models import Review
from apps.orders.models import Order, OrderItem, Store
from apps.cart.models import Cart, CartItem
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

fake = Faker()
User = get_user_model()


class Command(BaseCommand):
    help = "Idempotent seed: users, categories, attributes, products, images, reviews, orders"

    def add_arguments(self, parser):
        parser.add_argument(
            "--reset",
            action="store_true",
            help="Clear all data before seeding"
        )

    def handle(self, *args, **options):
        if options["reset"]:
            self.reset_database()

        self.stdout.write(self.style.WARNING("Seeding database..."))

        self.seed_users()
        self.seed_categories()
        self.seed_attributes()
        self.seed_products()
        self.seed_reviews()
        self.seed_orders()

        self.stdout.write(self.style.SUCCESS("SEED COMPLETED."))

    # ============================================================
    # RESET DATABASE
    # ============================================================
    def reset_database(self):
        self.stdout.write(self.style.WARNING("Resetting database..."))

        Review.objects.all().delete()
        OrderItem.objects.all().delete()
        Order.objects.all().delete()
        CartItem.objects.all().delete()
        Cart.objects.all().delete()
        ProductImage.objects.all().delete()
        ProductAttributeValue.objects.all().delete()
        Product.objects.all().delete()
        ProductAttribute.objects.all().delete()
        Category.objects.all().delete()
        Store.objects.all().delete()
        User.objects.exclude(is_superuser=True).delete()

        self.stdout.write(self.style.SUCCESS("Database cleared."))

    # ============================================================
    # USERS
    # ============================================================
    def seed_users(self):
        self.stdout.write(self.style.WARNING("Creating users..."))

        target = 10
        existing = User.objects.count()
        to_create = max(0, target - existing)

        for _ in range(to_create):
            email = fake.unique.email()
            user = User.objects.create_user(
                email=email,
                password="password123",
                first_name=fake.first_name(),
                last_name=fake.last_name(),
            )
            Cart.objects.get_or_create(user=user)

        self.stdout.write(self.style.SUCCESS("Users OK."))

    # ============================================================
    # CATEGORIES
    # ============================================================
    def seed_categories(self):
        self.stdout.write(self.style.WARNING("Creating categories..."))

        tree = {
            "Electronics": ["Smartphones", "Laptops", "Monitors", "Headphones"],
            "Home": ["Smart Home", "Kitchen", "Lighting"],
            "Gaming": ["Keyboards", "Mice", "Consoles"],
            "Clothing": ["T-Shirts", "Jeans", "Dresses", "Jackets"],
            "Sports": ["Fitness", "Outdoor", "Team Sports"],
            "Books": ["Fiction", "Non-Fiction", "Educational"],
            "Music": ["Instruments", "Records", "Accessories", "Studio Gear"],
            "Art": ["Painting", "Drawing", "Sculpting", "Craft Supplies"],
            "Travel": ["Luggage", "Accessories", "Outdoor Gear", "Maps"],
        }

        parent_map = {}

        for parent_name in tree.keys():
            slug = slugify(parent_name)
            parent, _ = Category.objects.get_or_create(
                slug=slug,
                defaults={"name": parent_name}
            )
            parent_map[parent_name] = parent

        for parent_name, children in tree.items():
            parent = parent_map[parent_name]
            for child_name in children:
                slug = slugify(child_name)
                Category.objects.get_or_create(
                    slug=slug,
                    defaults={"name": child_name, "parent": parent}
                )

        self.stdout.write(self.style.SUCCESS("Categories OK."))

    # ============================================================
    # ATTRIBUTES
    # ============================================================
    def seed_attributes(self):
        self.stdout.write(self.style.WARNING("Creating attributes..."))

        attribute_definitions = [
            ("Color", "color", ProductAttribute.TEXT, ""),
            ("Weight", "weight", ProductAttribute.NUMBER, "kg"),
            ("Wireless", "wireless", ProductAttribute.BOOLEAN, ""),
            ("Waterproof", "waterproof", ProductAttribute.BOOLEAN, ""),
            ("Brand", "brand", ProductAttribute.TEXT, ""),
        ]

        attributes = []

        for name, slug, value_type, unit in attribute_definitions:
            attr, _ = ProductAttribute.objects.get_or_create(
                slug=slug,
                defaults={"name": name, "value_type": value_type, "unit": unit}
            )
            attributes.append(attr)

        for cat in Category.objects.all():
            for attr in attributes:
                cat.attributes.add(attr)

        self.attributes = attributes
        self.stdout.write(self.style.SUCCESS("Attributes OK."))

    # ============================================================
    # PRODUCTS
    # ============================================================
    def seed_products(self):
        self.stdout.write(self.style.WARNING("Creating products..."))

        categories = Category.objects.filter(parent__isnull=False)
        target = 30 #КОЛИЧЕСТВО
        existing = Product.objects.count()
        to_create = max(0, target - existing)

        for _ in range(to_create):
            category = random.choice(categories)
            name = fake.sentence(nb_words=3).replace(".", "")
            slug = slugify(name)

            if Product.objects.filter(slug=slug).exists():
                slug = f"{slug}-{random.randint(1000, 9999)}"

            product = Product.objects.create(
                category=category,
                name=name,
                slug=slug,
                description=fake.paragraph(nb_sentences=5),
                price=random.randint(20, 2000),
                old_price=random.randint(20, 2000),
                stock=random.randint(0, 100),
                rating=round(random.uniform(0, 5), 1),
            )

            # ATTRIBUTE VALUES
            for attr in self.attributes:
                if attr.value_type == ProductAttribute.TEXT:
                    ProductAttributeValue.objects.create(
                        product=product,
                        attribute=attr,
                        value_text=fake.word()
                    )
                elif attr.value_type == ProductAttribute.NUMBER:
                    ProductAttributeValue.objects.create(
                        product=product,
                        attribute=attr,
                        value_number=round(random.uniform(0.1, 5.0), 2)
                    )
                elif attr.value_type == ProductAttribute.BOOLEAN:
                    ProductAttributeValue.objects.create(
                        product=product,
                        attribute=attr,
                        value_bool=random.choice([True, False, None])
                    )

            # IMAGES
            if not product.images.exists():
                for i in range(3):
                    url = f"https://picsum.photos/seed/{random.randint(1, 999999)}/600/600"
                    response = requests.get(url, verify=False, timeout=30)
                    if response.status_code == 200:
                        img_name = f"{product.slug}_{i}.jpg"
                        image = ProductImage(product=product, is_main=(i == 0))
                        image.image.save(img_name, ContentFile(response.content), save=True)

        self.stdout.write(self.style.SUCCESS("Products OK."))

    # ============================================================
    # REVIEWS
    # ============================================================
    def seed_reviews(self):
        self.stdout.write(self.style.WARNING("Creating reviews..."))

        users = list(User.objects.all())
        products = list(Product.objects.all())

        for product in products:
            # Если у продукта уже есть отзывы — пропускаем (idempotent)
            existing_users = set(
                Review.objects.filter(product=product).values_list("user_id", flat=True)
            )

            # Сколько отзывов хотим создать
            target_count = random.randint(1, 5)

            # Выбираем пользователей, которые ещё НЕ оставляли отзыв
            available_users = [u for u in users if u.id not in existing_users]

            # Если пользователей меньше, чем нужно — ограничиваем
            selected_users = random.sample(
                available_users,
                k=min(target_count, len(available_users))
            )

            for user in selected_users:
                Review.objects.create(
                    product=product,
                    user=user,
                    rating=random.randint(1, 5),
                    text=fake.paragraph(nb_sentences=3),
                )

        self.stdout.write(self.style.SUCCESS("Reviews OK."))


    # ============================================================
    # ORDERS
    # ============================================================
    def seed_orders(self):
        self.stdout.write(self.style.WARNING("Creating orders..."))

        users = list(User.objects.all())
        products = list(Product.objects.all())

        for _ in range(20):
            user = random.choice(users)

            order = Order.objects.create(
                user=user,
                customer_email=user.email,
                shipping_address=fake.address(),
                phone_number=fake.phone_number(),
                delivery_method=Order.DeliveryMethod.DELIVERY,
                total_price=0,
                idempotency_key=fake.uuid4(),
            )

            total = 0
            for _ in range(random.randint(1, 4)):
                product = random.choice(products)
                qty = random.randint(1, 3)

                OrderItem.objects.create(
                    order=order,
                    product=product,
                    product_name=product.name,
                    price=product.price,
                    quantity=qty,
                )

                total += product.price * qty

            order.total_price = total
            order.save()

        self.stdout.write(self.style.SUCCESS("Orders OK."))

===== .\apps\products\management\commands\__init__.py =====

===== .\apps\reviews\admin.py =====
# app_name/admin.py
from django.contrib import admin
from .models import Review

admin.site.register(Review)

===== .\apps\reviews\apps.py =====
from django.apps import AppConfig


class ReviewsConfig(AppConfig):
    name = 'apps.reviews'

    def ready(self):
        import apps.reviews.signals

===== .\apps\reviews\models.py =====
from django.conf import settings
from django.db import models
from apps.products.models import Product
from django.core.validators import MinValueValidator, MaxValueValidator



class Review(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE
    )
    product = models.ForeignKey(
        Product,
        related_name='reviews',
        on_delete=models.CASCADE
    )
    rating = models.PositiveSmallIntegerField(
         validators=[MinValueValidator(1), MaxValueValidator(5)] )
    text = models.TextField(blank=True, max_length=250)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('user', 'product')

===== .\apps\reviews\permissions.py =====
from rest_framework.permissions import BasePermission
from apps.orders.models import OrderItem, Order


class HasPurchasedProduct(BasePermission):
    """
    - GET / LIST — разрешены всем
    - POST — только если пользователь покупал товар
    - PUT / DELETE — только автор отзыва
    """

    def has_permission(self, request, view):
        # SAFE методы всегда разрешены
        if request.method in ("GET", "HEAD", "OPTIONS"):
            return True

        # Остальные — только для авторизованных
        if not request.user.is_authenticated:
            return False

        # Для создания отзыва проверяем покупку
        if request.method == "POST":
            product_id = view.kwargs.get("product_id")
            return OrderItem.objects.filter(
                order__user=request.user,
                order__status__in=[Order.Status.DELIVERED, Order.Status.COMPLETED],
                product_id=product_id,
            ).exists()

        return True

    def has_object_permission(self, request, view, obj):
        # SAFE методы — можно всем
        if request.method in ("GET", "HEAD", "OPTIONS"):
            return True

        # Редактировать/удалять может только автор
        return obj.user == request.user

===== .\apps\reviews\serializers.py =====
from rest_framework import serializers
from .models import Review



class ReviewSerializer(serializers.ModelSerializer):
    user_email = serializers.CharField(
        source='user.email',
        read_only=True
    )

    class Meta:
        model = Review
        fields = (
            'id',
            'rating',
            'text',
            'user_email',
            'created_at',
        )
        read_only_fields = ('id', 'created_at', 'user_email', 'product')

===== .\apps\reviews\signals.py =====
from django.db.models import Avg
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver

from .models import Review
from apps.products.models import Product



@receiver([post_save, post_delete], sender=Review)
def update_product_rating(sender, instance, **kwargs):
    product = instance.product
    avg = product.reviews.aggregate(
        avg=Avg('rating')
    )['avg'] or 0
    product.rating = round(avg, 1)
    product.save(update_fields=['rating'])

===== .\apps\reviews\tests.py =====
from django.test import TestCase

# Create your tests here.

===== .\apps\reviews\urls.py =====
from rest_framework.routers import SimpleRouter
from .views import ReviewViewSet



router = SimpleRouter()
router.register(
    'products/(?P<product_id>[^/.]+)/reviews',
    ReviewViewSet,
    basename='apps.reviews'
)

urlpatterns = router.urls

===== .\apps\reviews\views.py =====
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.filters import OrderingFilter
from rest_framework.pagination import PageNumberPagination
from django.db import IntegrityError
from rest_framework.exceptions import ValidationError
from .models import Review
from .serializers import ReviewSerializer
from .permissions import HasPurchasedProduct


class ReviewPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 50


class ReviewViewSet(ModelViewSet):
    serializer_class = ReviewSerializer
    permission_classes = [HasPurchasedProduct] #IsAuthenticated
    filter_backends = [OrderingFilter]
    ordering_fields = ['created_at', 'rating']
    ordering = ['-created_at']
    pagination_class = ReviewPagination

    def get_queryset(self):
        return Review.objects.filter(
            product_id=self.kwargs['product_id']
        ).select_related('user')

    def perform_create(self, serializer):
        try:
            serializer.save(
                user=self.request.user,
                product_id=self.kwargs['product_id']
            )
        except IntegrityError:
            raise ValidationError(
                {"подробнее": "Вы уже ознакомились с этим продуктом"}
            )
===== .\apps\reviews\__init__.py =====

===== .\apps\users\admin.py =====
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    ordering = ("email",)
    list_display = (
        "email",
        "first_name",
        "last_name",
        "gender",
        "birth_date",
        "is_staff",
        "is_active",
        "is_email_verified",
    )
    list_filter = ("gender", "is_staff", "is_email_verified", "is_active")
    search_fields = ("email", "first_name", "last_name")

    fieldsets = (
        (None, {"fields": ("email", "password")}),
        ("Personal info", {"fields": ("first_name", "last_name")}),
        ("Permissions", {"fields": ("is_active", "is_staff", "is_superuser", "groups", "user_permissions")}),
        ("Status", {"fields": ("is_email_verified",)}),
        ("Important dates", {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (
            None,
            {
                "classes": ("wide",),
                "fields": ("email", "password1", "password2"),
            },
        ),
    )

===== .\apps\users\apps.py =====
from django.apps import AppConfig


class UsersConfig(AppConfig):
    name = 'apps.users'

===== .\apps\users\managers.py =====
from django.contrib.auth.base_user import BaseUserManager


class UserManager(BaseUserManager):

    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email must be set")

        email = self.normalize_email(email)

        user = self.model(
            email=email,
            **extra_fields,
        )
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        extra_fields.setdefault("is_active", True)
        extra_fields.setdefault("is_email_verified", True)

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True")

        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True")

        return self.create_user(email, password, **extra_fields)

===== .\apps\users\models.py =====
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin
from django.db import models
from django.utils import timezone
from datetime import date

from .managers import UserManager



class User(AbstractBaseUser, PermissionsMixin):
    birth_date = models.DateField(null=True, blank=True)
    email = models.EmailField(unique=True)
    first_name = models.CharField(max_length=150, blank=True)
    last_name = models.CharField(max_length=150, blank=True)

    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_email_verified = models.BooleanField(default=True)


    date_joined = models.DateTimeField(default=timezone.now)

    objects = UserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    def __str__(self):
        return self.email

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}".strip()    
    
    

    class Gender(models.TextChoices):
        MALE = "male", "Male"
        FEMALE = "female", "Female"

    gender = models.CharField(
        max_length=10,
        choices=Gender.choices,
        null=True,
        blank=True,
    )

    @property
    def age(self):
        if not self.birth_date:
            return None

        today = date.today()
        return today.year - self.birth_date.year - (
            (today.month, today.day) < (self.birth_date.month, self.birth_date.day)
        )

===== .\apps\users\serializers.py =====
from rest_framework import serializers
from django.contrib.auth.password_validation import validate_password
from django.core.validators import validate_email

from .models import User
from datetime import date


class RegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = (
            "email",
            "password",
            "first_name",
            "last_name",
            "birth_date",
            "gender",
        )

    def validate_email(self, value): 
        value = value.lower() 
        # Проверка формата email 
        try: 
            validate_email(value) 
        except Exception: 
            raise serializers.ValidationError("Invalid email format") 
        # Проверка уникальности 
        if User.objects.filter(email=value).exists(): 
            raise serializers.ValidationError("User with this email already exists") 
        return value

    def validate_password(self, value):
        validate_password(value)
        return value

    def validate_birth_date(self, value):
        # Минимальный возраст: 12 лет (можно поменять)
        today = date.today()
        age = today.year - value.year - (
            (today.month, today.day) < (value.month, value.day)
        )

        if age < 12:
            raise serializers.ValidationError("You must be at least 12 years old")

        return value

    def create(self, validated_data):
        user = User.objects.create_user(
            email=validated_data["email"],
            password=validated_data["password"],
            first_name=validated_data.get("first_name", ""),
            last_name=validated_data.get("last_name", ""),
            birth_date=validated_data.get("birth_date"),
            gender=validated_data.get("gender", ""),
            is_active=True,
            is_email_verified=True,   # сразу активный
        )

        return user

===== .\apps\users\tests.py =====
from django.test import TestCase

# Create your tests here.

===== .\apps\users\throttles.py =====
from rest_framework.throttling import SimpleRateThrottle


class RegisterRateThrottle(SimpleRateThrottle):
    scope = "register"

    def get_cache_key(self, request, view):
        # Ограничиваем по IP
        ip = self.get_ident(request)
        return self.cache_format % {
            "scope": self.scope,
            "ident": ip,
        }

===== .\apps\users\urls.py =====
from django.urls import path
from .views import RegisterView, MeView

urlpatterns = [
    path('auth/register/', RegisterView.as_view(), name="register"),
    path('auth/me/', MeView.as_view(), name="me"),

]

===== .\apps\users\views.py =====
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.throttling import AnonRateThrottle
from .throttles import RegisterRateThrottle
from .serializers import RegisterSerializer


class RegisterView(APIView):
    throttle_classes = [AnonRateThrottle, RegisterRateThrottle]


    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()

        return Response(
            {
                "id": user.id,
                "email": user.email,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "is_email_verified": user.is_email_verified,
            },
            status=status.HTTP_201_CREATED,
        )


class MeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        return Response(
            {
                "id": user.id,
                "email": user.email,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "age": user.age,
                "birth_date": user.birth_date,
                "gender": user.gender,
                "is_staff": user.is_staff,
                "is_email_verified": user.is_email_verified,
            }
        )
    def patch(self, request):
        user = request.user

        user.first_name = request.data.get("first_name", user.first_name)
        user.last_name = request.data.get("last_name", user.last_name)

        user.save(update_fields=["first_name", "last_name"])

        return Response(
            {
                "message": "Profile updated",
                "first_name": user.first_name,
                "last_name": user.last_name,
            }
        )

===== .\apps\users\__init__.py =====

===== .\e_market\asgi.py =====
"""
ASGI config for e_market project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'e_market.settings')

application = get_asgi_application()

===== .\e_market\db.sqlite3 =====
[binary file skipped]
===== .\e_market\urls.py =====
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import(
    TokenObtainPairView,
    TokenRefreshView
)
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularSwaggerView,
    SpectacularRedocView,
)


from django.conf import settings 
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),

    path('api/auth/login/', TokenObtainPairView.as_view()),
    path('api/auth/refresh/', TokenRefreshView.as_view()),

    path('api/', include('apps.products.urls')),
    path('api/', include('apps.cart.urls')),
    path('api/', include('apps.orders.urls')),
    path('api/', include('apps.reviews.urls')),
    path('api/', include('apps.users.urls')),
    path("", include("apps.core.urls")),

    path('schema/', SpectacularAPIView.as_view(), name='schema'),
    path('swagger/', SpectacularSwaggerView.as_view(url_name='schema')),
    path('redoc/', SpectacularRedocView.as_view(url_name='schema')),
    
]

if settings.DEBUG: 
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
===== .\e_market\wsgi.py =====
"""
WSGI config for e_market project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'e_market.settings')

application = get_wsgi_application()

===== .\e_market\__init__.py =====

===== .\e_market\media\products\135\39e6ae8d-f20e-4fe2-8cab-a02bf7b28ca4.jpg =====
[binary file skipped]
===== .\e_market\media\products\135\b2591be9-c0db-4681-9cd6-3ca532309cf1.jpg =====
[binary file skipped]
===== .\e_market\media\products\135\d5a93739-3977-4300-af36-befacc43bada.jpg =====
[binary file skipped]
===== .\e_market\media\products\136\b56475b7-7e18-49b2-8f49-e203f29a1315.jpg =====
[binary file skipped]
===== .\e_market\media\products\136\bd4522a6-f886-49ac-8e90-6613d5185da5.jpg =====
[binary file skipped]
===== .\e_market\media\products\136\ff941979-ddeb-4c9a-9f56-3ddd5fa95b49.jpg =====
[binary file skipped]
===== .\e_market\media\products\137\424bc0f8-9638-420a-9572-9fd25a337743.jpg =====
[binary file skipped]
===== .\e_market\media\products\137\e3061ace-72c8-4e04-bb85-d188db44faf6.jpg =====
[binary file skipped]
===== .\e_market\media\products\137\e8ca2fc6-d6e7-4554-9241-b3bb40146951.jpg =====
[binary file skipped]
===== .\e_market\media\products\138\247f62e0-4a63-40d7-994e-77bab6eca89e.jpg =====
[binary file skipped]
===== .\e_market\media\products\138\61b4ef7e-bc49-4d59-9d3a-a7a40c256ce9.jpg =====
[binary file skipped]
===== .\e_market\media\products\138\c9ba89fe-7969-4185-949e-43fa5952a91d.jpg =====
[binary file skipped]
===== .\e_market\media\products\139\4cd2c3fa-2f46-43ec-af5e-57c8749935ee.jpg =====
[binary file skipped]
===== .\e_market\media\products\139\ad7969fa-37d7-4e93-941c-cebe2be8e036.jpg =====
[binary file skipped]
===== .\e_market\media\products\139\d2c97c58-163d-49e0-88c7-543cf5103550.jpg =====
[binary file skipped]
===== .\e_market\media\products\140\06fe6862-1396-42e5-85ef-ab1b7c3ec279.jpg =====
[binary file skipped]
===== .\e_market\media\products\140\110f9c2d-2135-4da9-bcbb-ecc3a9ce721e.jpg =====
[binary file skipped]
===== .\e_market\media\products\140\136b72c6-fac9-4251-aa90-7918fa2da98a.jpg =====
[binary file skipped]
===== .\e_market\media\products\141\b0e2978c-9873-4db3-8b12-000922fe1308.jpg =====
[binary file skipped]
===== .\e_market\media\products\141\bb228297-da65-448c-ba1d-8545975f0bc3.jpg =====
[binary file skipped]
===== .\e_market\media\products\141\f4129031-37c1-4523-b4d6-7f1510d11961.jpg =====
[binary file skipped]
===== .\e_market\media\products\142\b4439039-7581-4b01-933f-935da94028e8.jpg =====
[binary file skipped]
===== .\e_market\media\products\142\e1f73af4-7541-42dc-8219-b3ef705bda1c.jpg =====
[binary file skipped]
===== .\e_market\media\products\142\e9fafe65-c934-4be5-9198-1be784a01d0b.jpg =====
[binary file skipped]
===== .\e_market\media\products\143\4581b829-d398-48f2-9938-3285cc1cea30.jpg =====
[binary file skipped]
===== .\e_market\media\products\143\ab506be4-1722-403c-a848-f88b33d80e81.jpg =====
[binary file skipped]
===== .\e_market\media\products\143\e9434d59-b18f-43b5-8b91-28a7bb5670d9.jpg =====
[binary file skipped]
===== .\e_market\media\products\144\2c53d9e5-e9ff-425c-b5c9-400968fde233.jpg =====
[binary file skipped]
===== .\e_market\media\products\144\34ea1791-adb9-4c38-aa84-2c95d8d79b4f.jpg =====
[binary file skipped]
===== .\e_market\media\products\144\73e33631-9ae8-4748-94df-1e2a904ea2e7.jpg =====
[binary file skipped]
===== .\e_market\media\products\145\a91732c5-0d28-4b83-9a17-1426f8b62716.jpg =====
[binary file skipped]
===== .\e_market\media\products\145\bfd6f596-da28-4879-a8e6-2f19a4796285.jpg =====
[binary file skipped]
===== .\e_market\media\products\145\d758d84f-d81a-48f0-824a-e76696fe4d00.jpg =====
[binary file skipped]
===== .\e_market\media\products\146\455d2223-319e-480e-bb6c-1c9ae6bf85d2.jpg =====
[binary file skipped]
===== .\e_market\media\products\146\78645176-1ace-4d36-874f-e0e063f62f42.jpg =====
[binary file skipped]
===== .\e_market\media\products\146\81fa49db-84f6-4b7d-be6b-c2fd77349469.jpg =====
[binary file skipped]
===== .\e_market\media\products\147\29abff13-19c1-4334-b3b0-6e273c2d4922.jpg =====
[binary file skipped]
===== .\e_market\media\products\147\e9900215-4a47-400c-8fc9-fd3dbcea3e59.jpg =====
[binary file skipped]
===== .\e_market\media\products\147\eab89aa7-887d-4c45-b612-71f12f21377f.jpg =====
[binary file skipped]
===== .\e_market\media\products\148\57d8c188-fa72-452c-b554-a8edbab9c300.jpg =====
[binary file skipped]
===== .\e_market\media\products\148\595d8fcf-bdac-4ff0-b001-7161235449d8.jpg =====
[binary file skipped]
===== .\e_market\media\products\148\9e99366f-ac25-488a-bf33-590c9f079248.jpg =====
[binary file skipped]
===== .\e_market\media\products\149\b8f755e7-0e78-45bf-abf3-e141cc8aeb38.jpg =====
[binary file skipped]
===== .\e_market\media\products\149\ba964a12-2a3c-4b00-a446-f90c3072c42b.jpg =====
[binary file skipped]
===== .\e_market\media\products\149\f766ddab-eb43-4cc7-b1cc-34462bdbbfc1.jpg =====
[binary file skipped]
===== .\e_market\media\products\150\223478f5-7aa7-492f-836e-2f4c5ba7bab7.jpg =====
[binary file skipped]
===== .\e_market\media\products\150\293ef6ec-7e29-4a8b-8a4f-d0f2be37496d.jpg =====
[binary file skipped]
===== .\e_market\media\products\150\c98231b7-c289-4b09-8ebe-46862f5d81cb.jpg =====
[binary file skipped]
===== .\e_market\media\products\151\15a6d852-5336-41e3-8fc4-a454a8797e08.jpg =====
[binary file skipped]
===== .\e_market\media\products\151\901f287c-f4ef-4f3b-9439-84eedb9db0ac.jpg =====
[binary file skipped]
===== .\e_market\media\products\151\e100d3ed-579e-43a3-a861-fd419cfd505d.jpg =====
[binary file skipped]
===== .\e_market\media\products\152\1e6ad051-4f9f-4100-a984-4780cc205d8b.jpg =====
[binary file skipped]
===== .\e_market\media\products\152\d6e7a6c6-9d0f-411e-ac1a-b4460576c7e7.jpg =====
[binary file skipped]
===== .\e_market\media\products\152\eed13023-74d9-4914-ad7d-cad253f788f2.jpg =====
[binary file skipped]
===== .\e_market\media\products\153\2b3645ee-6b4a-413a-9b47-0cd8dc2f2b6c.jpg =====
[binary file skipped]
===== .\e_market\media\products\153\2b70479a-9a4c-4f94-b9d0-90bbcfd2df72.jpg =====
[binary file skipped]
===== .\e_market\media\products\153\d32dcfda-3b8e-4243-a39f-b0499ee6312c.jpg =====
[binary file skipped]
===== .\e_market\media\products\154\285df6a6-5189-477e-86a2-738461d08645.jpg =====
[binary file skipped]
===== .\e_market\media\products\154\65615c72-386f-42fb-b916-8abaab7e3777.jpg =====
[binary file skipped]
===== .\e_market\media\products\154\b9eb02da-a8f3-4c33-bed8-29e72bf92601.jpg =====
[binary file skipped]
===== .\e_market\media\products\155\0f0b5fe4-8e94-483c-a4f7-02fb18b90009.jpg =====
[binary file skipped]
===== .\e_market\media\products\155\c600cf80-4036-4bef-b13b-7b3a34d0d9a3.jpg =====
[binary file skipped]
===== .\e_market\media\products\155\f142376c-0de0-4e2c-8f0c-2373867c720b.jpg =====
[binary file skipped]
===== .\e_market\media\products\156\06cfc73a-e879-4765-97bd-64e8b67437a3.jpg =====
[binary file skipped]
===== .\e_market\media\products\156\6b971f34-23ff-45ca-a208-351b42202c56.jpg =====
[binary file skipped]
===== .\e_market\media\products\156\6efde09e-f405-4953-90de-507b1da04156.jpg =====
[binary file skipped]
===== .\e_market\media\products\157\665a36ed-3648-4dcd-9780-a2f728b8111c.jpg =====
[binary file skipped]
===== .\e_market\media\products\157\d549db26-88ad-4e08-8d77-0d78fa08d403.jpg =====
[binary file skipped]
===== .\e_market\media\products\157\e6660d91-6154-40b4-b02d-d52b576e540d.jpg =====
[binary file skipped]
===== .\e_market\media\products\158\0395668d-5360-4251-9522-988c7aeeaa70.jpg =====
[binary file skipped]
===== .\e_market\media\products\158\98d081ce-d0d7-4782-ab22-02a31c2d1736.jpg =====
[binary file skipped]
===== .\e_market\media\products\158\aef05b8a-eefd-4e9f-9ffc-a1ad4116ec9e.jpg =====
[binary file skipped]
===== .\e_market\media\products\159\049160ed-838e-42ba-8d9c-c990863ddfc6.jpg =====
[binary file skipped]
===== .\e_market\media\products\159\266a19a7-9a9d-4b21-bb1f-064ef9039279.jpg =====
[binary file skipped]
===== .\e_market\media\products\159\ae416fbd-f538-42c2-8080-cb4672602f6c.jpg =====
[binary file skipped]
===== .\e_market\media\products\160\47b4c765-0c7f-48d1-a04e-aa76a657cbee.jpg =====
[binary file skipped]
===== .\e_market\media\products\160\9c68f33f-804e-4f9d-b05a-b26f8a0bdb18.jpg =====
[binary file skipped]
===== .\e_market\media\products\160\e25215bb-15eb-4250-9fb4-00b92921f73d.jpg =====
[binary file skipped]
===== .\e_market\media\products\161\07528cac-d0b0-4b25-9cb5-107b9191d5ef.jpg =====
[binary file skipped]
===== .\e_market\media\products\161\74ac1895-598d-47cf-9984-7fd5adc26e94.jpg =====
[binary file skipped]
===== .\e_market\media\products\161\8a5a5388-ae76-4a11-86d6-d62e5aa896fe.jpg =====
[binary file skipped]
===== .\e_market\media\products\162\c4c17201-7285-43c9-8e0e-b98e9bb013f8.jpg =====
[binary file skipped]
===== .\e_market\media\products\162\d03ece32-1988-4e5a-8453-442768a28fdb.jpg =====
[binary file skipped]
===== .\e_market\media\products\162\e5fa191b-9b8d-4d3f-b8e0-1ac54bd4afbb.jpg =====
[binary file skipped]
===== .\e_market\media\products\163\5b86eec6-5f6d-4af5-ab7d-6ad352d2822d.jpg =====
[binary file skipped]
===== .\e_market\media\products\163\8001d1e1-e395-47f3-9cec-381a1f0a4897.jpg =====
[binary file skipped]
===== .\e_market\media\products\163\9c311377-f021-4157-9392-71b90e9de16e.jpg =====
[binary file skipped]
===== .\e_market\media\products\164\085791fc-7142-46b7-8338-89a0ce5b6109.jpg =====
[binary file skipped]
===== .\e_market\media\products\164\16d3a420-dc21-40ef-96bc-f38c3f1fce1d.jpg =====
[binary file skipped]
===== .\e_market\media\products\164\46d21871-e101-4415-b4e2-f6aae9e509d0.jpg =====
[binary file skipped]
===== .\e_market\settings\base.py =====
from datetime import timedelta
from pathlib import Path
import os
from corsheaders.defaults import default_headers

from dotenv import load_dotenv
load_dotenv()


BASE_DIR = Path(__file__).resolve().parent.parent
#            ^ settings/    ^ e_market/ ^ корень проекта (где manage.py) 

MEDIA_URL = '/media/' 
MEDIA_ROOT = BASE_DIR / 'media'


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get("DJANGO_DEBUG", "False") == "True"


# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get("DJANGO_SECRET_KEY")

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    

        # third-party
    'rest_framework',
    'django_filters',
    'corsheaders',
    #'drf_yasg',
    'drf_spectacular',

    # local apps
    'apps.users',
    'apps.cart',
    'apps.orders',
    'apps.common',
    'apps.reviews',
    'apps.products.apps.ProductsConfig',
    
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    
    "apps.common.middleware.SentryUserMiddleware",
]

ROOT_URLCONF = 'e_market.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'e_market.wsgi.application'


# Database
# https://docs.djangoproject.com/en/6.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
        'ATOMIC_REQUESTS': True,
    }
}


# Password validation
# https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        "OPTIONS": {"min_length": 6},
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/6.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/6.0/howto/static-files/

STATIC_URL = 'static/'


AUTH_USER_MODEL = 'users.User'

REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
    
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
    'DEFAULT_PAGINATION_CLASS':
        'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,


     'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.AllowAny',  #IsAuthenticated
    ),
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
    'DEFAULT_PAGINATION_CLASS':
        'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "anon": "200/hour",
        "user": "1000/day",
        "register": "5/hour",
    },
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=30),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'AUTH_HEADER_TYPES': ('Bearer',),
}


CORS_ALLOW_CREDENTIALS = True

CORS_ALLOWED_ORIGINS = [
    #"http://localhost:5173",
    "http://localhost:3000",
]

CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
]

CORS_ALLOW_HEADERS = list(default_headers) + [
    "accept",
    "accept-encoding",
    "authorization",
    "content-type",
    "origin",
    'dnt',
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
    "idempotency-key",
]

CORS_ALLOW_METHODS = [
    "GET",
    "POST",
    "PUT",
    "PATCH",
    "DELETE",
    "OPTIONS",
]

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

===== .\e_market\settings\dev.py =====
from .base import *

DEBUG = True

ALLOWED_HOSTS = ["*"]

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}




SECRET_KEY = "unsafe-dev-key"
===== .\e_market\settings\prod.py =====
from .base import *
import os
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration
# Database (Postgres через DATABASE_URL)
import dj_database_url

SENTRY_DSN = os.environ.get("SENTRY_DSN")

if SENTRY_DSN:
    sentry_sdk.init(
        dsn=SENTRY_DSN,
        integrations=[DjangoIntegration()],

        # performance / tracing
        traces_sample_rate=0.1,   # 10% запросов
        send_default_pii=False,   # НЕ слать персональные данные

        environment="production",
        release=os.environ.get("RELEASE", "unknown"),
    )

DATABASES = {
    "default": dj_database_url.config(conn_max_age=600, ssl_require=True)
}

DEBUG = False

SECRET_KEY = os.environ.get("DJANGO_SECRET_KEY")

if not SECRET_KEY:
    raise RuntimeError(
        "DJANGO_SECRET_KEY environment variable is not set. "
        "Refusing to start in production."
    )



ALLOWED_HOSTS = os.environ.get("ALLOWED_HOSTS", "").split(",")

# Security
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

SECURE_HSTS_SECONDS = 3600
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

X_FRAME_OPTIONS = "DENY"


DATABASES = {
    "default": dj_database_url.config(conn_max_age=600, ssl_require=True)
}

# Static
STATIC_ROOT = BASE_DIR / "staticfiles"

# Logging (минимальный прод уровень)
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,

    "formatters": {
        "simple": {
            "format": "%(levelname)s %(asctime)s %(name)s %(message)s"
        },
        "structured": {
            "format": (
                '{"level": "%(levelname)s", '
                '"time": "%(asctime)s", '
                '"logger": "%(name)s", '
                '"message": "%(message)s"}'
            )
        },
    },

    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "structured",   # ВАЖНО: structured в проде
        },
    },

    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },

    "loggers": {
        "django": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False,
        },
        "django.request": {
            "handlers": ["console"],
            "level": "ERROR",
            "propagate": False,
        },
    },
}



INTERNAL_IPS = ["127.0.0.1"]


CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": os.environ.get("REDIS_URL", "redis://127.0.0.1:6379/1"),
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
        "TIMEOUT": 300,
    }
}

===== .\e_market\settings\__init__.py =====
import os

DJANGO_ENV = os.getenv("DJANGO_ENV", "dev")

if DJANGO_ENV == "prod":
    from .prod import *
elif DJANGO_ENV == "dev":
    from .dev import *
else:
    raise RuntimeError(f"Unknown DJANGO_ENV: {DJANGO_ENV}")
